# -*- coding: utf-8 -*-
"""
/***************************************************************************
 readLyrx
                                 A QGIS plugin
 Apply arcgis pro .lyrx style
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-09
        git sha              : $Format:%H$
        copyright            : (C) 2019 by arc2qgis
        email                : dror.bogin@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from qgis.core import *
import json
import qgis.utils

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .qlyrx_dialog import readLyrxDialog
import os.path

point2mm =  0.352778

class readLyrx:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'readLyrx_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)
        
        self.dlg = readLyrxDialog()
        
        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&readLyrx')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('readLyrx', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/readLyrx/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Apply lyrx symbology'),
            callback=self.run,
            parent=self.iface.mainWindow())
        # will be set False in run()
        self.first_start = True
        


    def load_vectors(self):
        """
        Populate the layer selection with vector layers only
        """
        self.dlg.layer_select.clear()
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        vector_layers = []
        for layer in layers:
            if layer.type() ==  QgsMapLayer.VectorLayer:
                vector_layers.append(layer.name())
        self.dlg.layer_select.addItems(vector_layers)

    
    def read_lyrx(self, file=None):    
        with open(file, mode="r", encoding="utf-8") as json_file:  
            data = json.load(json_file)
        return data

    
    def readValueDef(self, obj):
        return obj['symbol']['symbol']['symbolLayers']


    def checkSymbolType(self, obj):    
        obj_arr = {}
        sl_idx = 0
        for o in obj:       
            if not 'desc' in obj_arr  :
                obj_arr['desc'] = []
            type = o['type']    
            if  not type in obj_arr  :
                obj_arr[type] = 0
            obj_arr[type] = obj_arr[type] + 1
            o['sl_idx'] = sl_idx
            obj_arr['desc'].append(o)
            sl_idx = sl_idx + 1
        #print(sl_idx)
        if 'CIMHatchFill' in obj_arr:
            obj_arr['template'] = 'hatch'
            obj_arr['template_hatch_num'] = obj_arr['CIMHatchFill']        
        else:
            obj_arr['template'] = 'simple'
        if 'CIMLineSymbol' in obj_arr:
            obj_arr['template_line_num'] = obj_arr['CIMLineSymbol']        
        if 'CIMSolidFill' in obj_arr:
            obj_arr['template_solid_num'] = obj_arr['CIMSolidFill']
        if 'CIMSolidStroke' in obj_arr:
            obj_arr['template_stroke_num'] = obj_arr['CIMSolidStroke']
        return obj_arr


    def parseSymbolLayerSolidFill(self, layers):
        colors = []
        for l in layers:
            if l['type'] == 'CIMSolidFill':            
                temp_color = l['color']['values']
                new_color = self.colorToRgbArray(temp_color, l['color']['type'])
                colors.append(new_color)
        return colors

    def generalise_geom_type(self, layer):
        geometry_type_str = QgsWkbTypes.displayString(int(layer.wkbType()))
        geometry_type = layer.wkbType()
        geometry_general_type_str = geometry_type_str.replace('Multi', '').lower()  
        geometry_general_type_str = geometry_general_type_str.replace('string', '')
        return geometry_general_type_str


    def parseSolidFill(self, obj, layer):
        symbol = ""
        i = 0
        solid_index = -1
        for ls in obj['desc']:
            if ls['type'] == 'CIMSolidFill' and ls['enable']:
                temp_color = ls['color']['values']
                new_color = self.colorToRgbArray(temp_color, ls['color']['type'])            
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(new_color)  
                #print("solid index " + str(ls['sl_idx']))
                #symbol.setStrokeColor(new_color)     
                solid_index = ls['sl_idx']
                i = i + 1
        if i > 1:
            print("Extra " + str(i) + " solid fills")
        # Add default shape fill.
        if symbol == '' or  self.generalise_geom_type(layer) == 'line':
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                new_color = self.colorToRgbArray([255,255,255,0], 'CIMRGBColor')
                symbol.setColor(new_color)
        #symbol['order'] = 0
        return [symbol, solid_index]


    def parseStroke(self, obj, symb, layer):                
        layers = []
        i = 0
        for ls in obj['desc']:
            #print(ls)
            if ls['type'] == 'CIMSolidStroke' and ls['enable']:
                dp = self.parseStrokeEffects(ls)
                #print(dp)
                temp_color = ls['color']['values']
                new_color = self.colorToRgbArray(temp_color, ls['color']['type'])
                #stroke_width = ls['width'] if ls['width'] < 2 else ls['width']*point2mm             
                stroke_width = ls['width']*point2mm             
                if  i == 0 and  dp == '' and i > 9:
                    #print(geometry_general_type_str)
                    if not self.generalise_geom_type(layer) == 'line':
                        #print("stroke not line change the first SL")
                        symb.symbolLayer(0).setStrokeColor(new_color)
                        symb.symbolLayer(0).setStrokeWidth(stroke_width)                
                    else:
                        symb.symbolLayer(0).setColor(new_color)
                        symb.symbolLayer(0).setWidth(stroke_width)                
                    if not dp == '':
                        #print("dash pattern in first layer")
                        symb.symbolLayer(0).setUseCustomDashPattern(True)
                        symb.symbolLayer(0).setCustomDashVector(dp)
                            
                else :
                    #print("Another stroke layer")
                    # Add simple line symbol layer (stroke)
                    #if not geometry_general_type_str == 'line':
                    symbol_layer = QgsSimpleLineSymbolLayer()
                    #else:
                        #symbol_layer = QgsMarkerLineSymbolLayer()
                    symbol_layer.setColor(new_color)
                    symbol_layer.setWidth(stroke_width)
                    # TODO: Check offset def (in poly etc)
                    if not self.generalise_geom_type(layer) == 'line':
                        symbol_layer.setOffset(stroke_width/2)
                    # TODO: Read join and shape
                    if not self.generalise_geom_type(layer) == 'line':
                        symbol_layer.setPenJoinStyle(0)
                    if not dp == '':
                        #print("dp in " + str(i) + " stroke symbol")
                        symbol_layer.setUseCustomDashPattern(True)
                        symbol_layer.setCustomDashVector(dp)
                    #print("stroke symbol idx is " + str(ls['sl_idx']))  
                    stroke_order = ls['sl_idx']
                    symb.insertSymbolLayer(stroke_order, symbol_layer)            
                    #print(symbol_layer.color())
                i = i + 1            
        return symb


    def parseStrokeEffects(self, obj):
        dash_pattern = ''
        temp_array = []
        if 'effects' in obj:
            #print("effects")
            if obj['effects'][0]['type'] == 'CIMGeometricEffectDashes' :
               #print("dash") 
                temp_pattern = obj['effects'][0]['dashTemplate']
                for tp in temp_pattern:
                    temp_array.append(tp*point2mm)
                dash_pattern = temp_array   
                #print(dash_pattern)
        return dash_pattern


    def parseLineFill(self, obj):
        isDoubleHatch = False
        isOffsetEqFirstWidth = True 
        symbol = ""
        layers = []
        i = 0
        first_width = 0
        prev_hatch = 0
        for ls in obj['desc']:        
            if ls['type'] == 'CIMHatchFill' and ls['enable']:            
                symb_def = ls['lineSymbol']['symbolLayers'][0]
                # New definitions
                angle = ls['rotation'] if 'rotation' in ls else 0            
                temp_color = symb_def['color']['values']
                new_color = self.colorToRgbArray(temp_color, symb_def['color']['type'])
                # Hatch definitions
                fill_width = symb_def['width'] if 'width' in symb_def else 1
                fill_width = fill_width*point2mm
                fill_distance = ls['separation'] if 'separation' in ls else 0
                fill_distance = fill_distance*point2mm
                fill_offset = ls['offsetX'] if 'offsetX' in ls else 0
                fill_offset = fill_offset*point2mm
                # Create symbol
                symbol_layer = QgsLinePatternFillSymbolLayer()
                symbol_layer.setColor(new_color)
                symbol_layer.setLineAngle(angle)
                symbol_layer.setLineWidth(fill_width)
                symbol_layer.setDistance(fill_distance)            
                # Tweak save the first hatch width and use as offset
                # TODO: Real fix, mark problematic files and unusual offsets
                if prev_hatch > 0 :
                    symbol_layer.setLineWidth(fill_width)
                    symbol_layer.setOffset(fill_width)
                    isOffsetEqFirstWidth = fill_width == prev_hatch
                    isDoubleHatch = True

                layers.append(symbol_layer)
                if i == 0:
                    prev_hatch = fill_width
                i = i + 1
                    
        if len(layers) > 0:
            return layers
        else:
            return symbol


    def cmyk2Rgb(self, cmyk_array):
        c = cmyk_array[0]
        m  = cmyk_array[1]
        y  = cmyk_array[2]
        k  = cmyk_array[3]
        
        r = int((1 - ((c + k)/100)) * 255)
        g = int((1 - ((m + k)/100)) * 255)
        b = int((1 - ((y + k)/100)) * 255)
        
        return [r, g, b]


    def colorToRgbArray(self, color_array, type):
        opacity = 255
        if len(color_array) > 2 and type == 'CIMRGBColor':
            opacity = color_array[3]/100*255
            new_color = QColor.fromRgb(color_array[0],color_array[1], color_array[2], opacity) 
            #print(opacity)
        else:    
            new_color = QColor.fromRgb(color_array[0],color_array[1], color_array[2])        
        if type == 'CIMHSVColor':
            new_color = QColor.fromHsvF(color_array[0]/360,color_array[1]/100, color_array[2]/100,1)
        elif type == 'CIMCMYKColor':
            temp_color = self.cmyk2Rgb(color_array)
            new_color = QColor.fromRgb(temp_color[0],temp_color[1], temp_color[2])
        return new_color


    def parseSimpleRenderer(self, obj):
        symbol = ''
        symb_def = obj['symbol']['symbol']['symbolLayers'][0]
        if 'characterIndex' in symb_def and symb_def['type'] == 'CIMCharacterMarker':
            symbol = self.parseCharacterFill(symb_def, 0)
        return symbol


    def parseCharacterFill(symb_def, max_size):
        symbol = self.QgsFontMarkerSymbolLayer()
        
        symbol.setFontFamily(symb_def['fontFamilyName'])
        symbol.setCharacter(chr(symb_def['characterIndex']))
        new_size = symb_def['size']*point2mm
        symbol.setSize(symb_def['size']*point2mm)
        #symbol.markerOffsetWithWidthAndHeight()
        if 'rotation' in symb_def:
            new_angle = symb_def['rotation']
            if new_angle < 0:
                new_angle = abs(new_angle)
            elif new_angle > 180:
                new_angle = 360 - new_angle
            symbol.setAngle(new_angle)
            # Fix offset - rotation twaek
            #symbol.setOffset(QPointF(0.3,0.0))
            #offset_tweak = (max_size - new_size)/2 if max_size > new_size else 0
            #print(offset_tweak)
            #if offset_tweak > 0:
            #    symbol.setOffset(QPointF(0,0))
        #print(symb_def['characterIndex'])
        # Check fill color 
        if 'symbol' in symb_def :
            if 'symbolLayers' in symb_def['symbol']:
                color = self.parseSymbolLayerSolidFill(symb_def['symbol']['symbolLayers'])
                #print(color)
                symbol.setColor(color[0])
        if not self.generalise_geom_type(layer) == 'point':
            symbol_base = QgsPointPatternFillSymbolLayer()
            if 'stepX' in symb_def['markerPlacement']:
                symbol_base.setDistanceX(symb_def['markerPlacement']['stepX']*point2mm)
                symbol_base.setDistanceY(symb_def['markerPlacement']['stepY']*point2mm)    
            
            
            marker = QgsMarkerSymbol()
            marker.changeSymbolLayer(0, symbol)
            symbol_base.setSubSymbol(marker)
            
            return symbol_base
        else:    
            return symbol


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&readLyrx'),
                action)
            self.iface.removeToolBarIcon(action)


    def apply_lyrx_symbols(self, layer, lyrx_data, geometry_general_type_str):
        simple_symbol = False
        layerDef = lyrx_data['layerDefinitions']
        renderer = ''
        renderers = [];
        renderers_symb_type = []
        dataset_names = []

        for p in layerDef :
            #print(p['name'])
            temp_renderer = p['renderer'] if 'renderer' in p else ''
            renderers.append(temp_renderer)
            if not temp_renderer == '':
                rend_type = temp_renderer['symbol']['type'] if 'symbol' in temp_renderer else  temp_renderer['defaultSymbol']['symbol']['type']
                renderers_symb_type.append(rend_type.lower())
                dataset = p['featureTable']['dataConnection']['dataset']
                dataset_names.append(dataset)

        #print(renderers_symb_type)
        #print(dataset_names)
        # Find a renderer with the active layer field attribute
        rend_to_check = []
        x = 0
        for r in renderers_symb_type:
            #print(r)
            if self.generalise_geom_type(layer) in r:            
                rend_to_check.append(x)
            x = x + 1

        rend_idx = -1
        #print(rend_to_check)
        # Check in the active layers for matching classification fields  
        for z in rend_to_check:
            #print(renderers[z]['fields'][0])
            #print(layer.fields())
            field_exist = layer.fields().indexFromName(renderers[z]['fields'][0])
            if field_exist > -1:
                rend_idx = z
        # Check simple symbol        
        if rend_idx < 0:
            active_name = layer.sourceName()
            rend_idx = dataset_names.index(active_name)
            simple_symbol = True


        if rend_idx > -1 and not simple_symbol:
            categories = []
            class_field = renderers[rend_idx]['fields'][0] if len(renderers[rend_idx]['fields']) > 0 else 'CODE'
            class_field2 = renderers[rend_idx]['fields'][1] if len(renderers[rend_idx]['fields']) > 1 else ''
            #print(class_field)
            classes = renderers[rend_idx]["groups"][0]["classes"]
            symbols_labels = []
            symbol_layers = []
            symbol_values = []    
            for c in classes :    
                symbol_layers.append(self.readValueDef(c))
                symbols_labels.append(c['label'])
                symbol_values.append(c['values'][0]['fieldValues'])
            
            #print(symbol_layers)
            idx = 0
            for sl in symbol_layers:
                #print(sl[0]['type'])
                symbol_def = self.checkSymbolType(sl)
                #print(symbol_def)
                ret_arr = self.parseSolidFill(symbol_def, layer)
                ret = ret_arr[0]
                #print("solid fill idx " + str(ret_arr[1])) 
                #print(ret)
                #print ("val :" + str(symbol_values[idx][0]))
                line_ret = self.parseLineFill(symbol_def)
                #print(len(line_ret))
                if not line_ret == '':
                    #print("hatch number is " + str(len(line_ret)))
                    for line in line_ret:
                        ret.appendSymbolLayer(line)
                
                if 'template_stroke_num' in symbol_def and not ret == '':
                    
                    ret = self.parseStroke(symbol_def, ret, layer)  
                #print(len(sl))
                #if 'characterIndex' in sl[0] and sl[0]['type'] == 'CIMCharacterMarker':        
                layers = []
                max_size = 0
                for charSl in sl:            
                    if 'characterIndex' in charSl and charSl['type'] == 'CIMCharacterMarker':
                        #print(charSl["enable"])
                        if charSl["enable"]:
                            symbol = self.parseCharacterFill(charSl, max_size)
                            if not symbol == '':
                                print("char symb desc " + str(charSl['sl_idx']))
                                layers.append(symbol)    
                                if self.generalise_geom_type(layer) == 'point':          
                                    max_size = max(symbol.size(), max_size)
                # Add the font fill in reverse order
                x = 0
                #print(str(len(layers)) + " Character marker symbols")
                for rl in reversed(layers):
                    ret.appendSymbolLayer(rl)
                    #ret.symbolLayer(0).markerOffsetWithWidthAndHeight(ret, max_size, max_size)
                    x = x + 1

                symbol_val_prep = symbol_values[idx][0] + ", " + symbol_values[idx][1] if len(symbol_values[idx]) > 1 else symbol_values[idx][0]
                #category = QgsRendererCategory(symbol_values[idx][0], ret, symbols_labels[idx])
                category = QgsRendererCategory(symbol_val_prep, ret, symbols_labels[idx])
                categories.append(category)
                idx = idx + 1
                #print(idx)    
            
            concat_str =  ", " + "', ', " + class_field2 + ")" if not class_field2 == "" else ")"
            renderer = QgsCategorizedSymbolRenderer("concat(" + class_field + concat_str, categories)
            
        elif renderers[rend_idx]['type'] == 'CIMSimpleRenderer' and simple_symbol:
            single_symbology = self.parseSimpleRenderer(renderers[rend_idx])
            if not single_symbology == '':
                #print('uni')
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.changeSymbolLayer(0, single_symbology)
                renderer = QgsSingleSymbolRenderer(symbol)
        else:
            print("No matching lyrx symbology fields found for the active layer")

        # assign the created renderer to the layer
        if not renderer == '' :
            #print("re-render")
            layer.setRenderer(renderer)
            layer.triggerRepaint()


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        # show the dialog
        self.dlg.show()
        self.load_vectors()
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            j_data = self.read_lyrx(self.dlg.file_select.filePath())
            
            layer = self.dlg.layer_select.currentLayer()
            #print(layer)
            #print(point2mm)
            fields = layer.fields()
            
            geometry_general_type_str = self.generalise_geom_type(layer)
            
            self.apply_lyrx_symbols(layer, j_data, geometry_general_type_str)
            #pass
